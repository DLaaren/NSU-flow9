// 1. Реализуйте PEG-парсер для грамматики простых арифметических выражений 
// (целые константы, операции + и *), 
// который порождает дерево синтаксического разбора (AST). Используйте библиотеку lingo. 
// 2. Преобразуйте дерево обратно в строку. 
// 3. Реализуйте калькулятор, вычисляющий значение арифметического выражения. 

import lingo/pegcode/driver;
import string;
import math/math;

//custom flow structures

Expression ::= Multiply, Add, Const;

Multiply    (l : Expression, r : Expression);
Add         (l : Expression, r : Expression);
Const       (const : int);


// 1.
lingoGrammar() {
    compilePegGrammar("#include lab5.lingo");
}

// 2.
ExprToString(expr: Expression) -> string {
    switch(expr) {
        Multiply(l, r)  : "(" + ExprToString(l) + "*" + ExprToString(r) + ")";
        Add(l, r)       : "(" + ExprToString(l) + "+" + ExprToString(r) + ")";
        Const(const)    : i2s(const);
    }
}

// 3.
calculate(expr: Expression) -> Maybe<int> {
    //define lamda "getValue
    getValue = \l, r, operator -> {
        switch(calculate(l)) {
            Some(left)  : switch(calculate(r)) {
                Some(right) : operator(left, right);
                None()      : None();
            };
            None()      : None();
        }
    }

    switch(expr) {
        Multiply(l, r)  : getValue(l, r, \left, right -> Some(left * right));
        Add(l ,r)       : getValue(l, r, \left, right -> Some(left + right));
        Const(const)    : Some(const); 
    }
}


main() {
    // get an expression
    expr = getUrlParameter("expr");

    usage : string = "Usage: lab5.flow -- \"expr=<expression>\"";
	
    if (expr == "") {
		println("Expressinon expected");
		println(usage);
		quit(-1);
	} else {
        e = parsic(lingoGrammar(), expr, defaultPegActions);
        println(e);

        switch(calculate(e)) {
            Some(result)    : println(ExprToString(e) + " = " + i2s(result));
            None()          : println("Error while calculating");
        }
		quit(0);
	}
}