import lingo/pegcode/driver;
import string;
import math/math;

import infix;

buildOp(xs : [flow]) {
	fold(xs[2], xs[1], \acc, x -> BinOp(xs[0], acc, x));
}

lingoGrammar() {
    compilePegGrammar("#include infix.lingo");
}

parse(source: string) {
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildOp", buildOp);
		SemanticActions(t1);
	}
	parsic(lingoGrammar(), source, specialPegActions);
}

inputVariablesIntoTree() -> Tree<string, Rational> {
    variables = strSplit(getUrlParameter("vars"), ",");
    fold(variables, makeTree(),\ tree, variable -> {
        if (strContains(getUrlParameter(variable), "/")) {
            nums = strSplit(getUrlParameter(variable), "/");
            a = s2i(nums[0]);
            b = s2i(nums[1]);
            setTree(tree, variable, Rational(a,b));
        } else if (getUrlParameter(variable) != "") {
            a = s2i(getUrlParameter(variable));
            setTree(tree, variable, Rational(a,1));
        } else {
            setTree(tree, variable, Error);
        }
    });
}

main() {
    // get an expression
    expr = getUrlParameter("expr");

    // get tree with constants
    VarsTree : Tree<string, Rational> = inputVariablesIntoTree();

    usage : string = "Usage: infix_calculator.flow -- \"expr=<expression>\" \"vars=<variables>\" \"<variable1>=<value1>\" ...";
	
    if (expr == "") {
		println("Expressinon expected");
		println(usage);
		quit(-1);
	} else {
        e = parse(expr);
		println(e);

        result : Pair<string, Maybe<Rational>> = calculateWrapper(e, VarsTree);
        println("simplified expression :: " + firstOfPair(result));

        switch(secondOfPair(result)) {
            Some(res) : println(firstOfPair(result) + " = " + InfixToString(res));
            None() : println("error while calculating");
        }

		quit(0);
    }
}