import lingo/pegcode/driver;
import string;
import math/math;
import ds/egraph;
import ds/egraph_matching;

export {

    Expression ::= Var, Rational, BinOp, Neg, Diff;

    Var(var : string);
    Rational(l: int, r : int);
    Error = Rational(0,0);
    RationalOne = Rational(1,1);
    RationalZero = Rational(0,1);
    BinOp(OpName : string, l : Expression, r : Expression);
    Neg(e: Expression);
    Diff(e : Expression, x : Var);
    Polynom(num : Expression, denom : Expression);
    PolynomError = Polynom(Error, Error);

    parse(source : string) -> Expression;
    inputVariablesIntoTree() -> Tree<string, Rational>;
    InfixToString(expr: Expression) -> string;
    calculate(expr: Expression, VarsTree: Tree<string, Rational>) -> Maybe<Rational>;
    calculateWrapper(expr: Expression, VarsTree: Tree<string, Rational>) -> Pair<string, Maybe<Rational>>;
}

buildOp(xs : [flow]) {
	fold(xs[2], xs[1], \acc, x -> BinOp(xs[0], acc, x));
}

lingoGrammar() {
    compilePegGrammar("#include infix.lingo");
}

parse(source: string) -> Expression {
	specialPegActions = {
		t1 = setTree(defaultPegActions.t, "buildOp", buildOp);
		SemanticActions(t1);
	}
	parsic(lingoGrammar(), source, specialPegActions);
}

inputVariablesIntoTree() -> Tree<string, Rational> {
    variables = strSplit(getUrlParameter("vars"), ",");
    fold(variables, makeTree(),\ tree, variable -> {
        if (strContains(getUrlParameter(variable), "/")) {
            nums = strSplit(getUrlParameter(variable), "/");
            a = s2i(nums[0]);
            b = s2i(nums[1]);
            setTree(tree, variable, Rational(a,b));
        } else if (getUrlParameter(variable) != "") {
            a = s2i(getUrlParameter(variable));
            setTree(tree, variable, Rational(a,1));
        } else {
            setTree(tree, variable, Error);
        }
    });
}


InfixToString(expr: Expression) -> string {
    switch(expr) {
        Var(var) : var;
        Rational(l,r) : {
            if (r == 1) {
                i2s(l);
            } 
            else if (l == 0) {
                i2s(0);
            } else {
                i2s(l) + "/" + i2s(r);
            }
        }
        BinOp(OpName, l, r) : "(" + InfixToString(l) + " " + OpName + " " + InfixToString(r) +")"
        Neg(e) : "(" + "-" + InfixToString(e) + ")";
        Diff(e, x) : "(" + "d/d" + InfixToString(x) + " " + InfixToString(e) + ")";
    }
}

calculate(expr: Expression, VarsTree: Tree<string, Rational>) -> Maybe<Rational> {
    getValue = \l,r, operator -> {
        switch(calculate(l, VarsTree)) {
            Some(left) : switch(calculate(r, VarsTree)) {
                Some(right) : operator(left, right);
                None() : None();
            };
            None() : None();
        }
    }

    add = \left, right -> {
        if (left.r == right.r) {
            calculate(Rational(left.l + right.l, left.r), VarsTree);
        } else {
            calculate(Rational(left.l * right.r + right.l * left.r, left.r * right.r), VarsTree);
        }
    }
    sub = \left, right -> {
        if (left.r == right.r) {
            calculate(Rational(left.l - right.l, left.r), VarsTree);
        } else {
            calculate(Rational(left.l * right.r - right.l * left.r, left.r * right.r), VarsTree);
        }
    }
    mult = \left, right -> {
        calculate(Rational(left.l * right.l, left.r * right.r), VarsTree);
    }
    div = \left, right -> {
        calculate(Rational(left.l * right.r, left.r * right.l), VarsTree);
    }

    switch(expr) {
        Var(var) : switch(lookupTree(VarsTree, var)) {
            Some(num) : {
                if (num != Error) {
                    Some(num);
                } else {
                    None();
                }
            }
            None() : None();
        }

        Rational(l, r) : {
            Some(Rational(l,r));
        }

        BinOp(OpName, l, r) : {
            if (OpName == "+") {
                getValue(l,r, \left, right -> add(left, right));
            }
            else if (OpName == "-") {
                getValue(l,r, \left, right -> sub(left, right));
            }
            else if (OpName == "*") {
                getValue(l,r, \left, right -> mult(left, right));
            }
            else if (OpName == "/") {
                getValue(l,r, \left, right -> div(left, right));
            } else {
                None();
            }
        }

        Neg(e) : switch(calculate(e, VarsTree)) {
            Some(value) : {
                left = value.l;
                right = value.r;
                Some(Rational(-left, right));
            }
            None() : None();
        }
 
        Diff(e,x) : switch(lookupTree(VarsTree, x.var)) {
            Some(value) : {
                if (value != Error) {
                    calculate(derivation(e,x), VarsTree);
                }
                else {
                    None();
                }
            }
            None() : None();
        }
    }
}

normalization(result : Maybe<Rational>) -> Maybe<Rational> {
    switch(result) {
        Some(res) : {
            if (res.r == 0) {
                None();
            }
            else if (res.l == 0 && res.r == 1) {
                Some(RationalZero);
            }
            else if (res.l == res.r) {
                Some(RationalOne);
            }
            else {
                gcd = gcd(res.l, res.r);
                if (gcd < 0) {
                    Some(Rational(res.l / (-gcd), res.r / (-gcd)));
                }
                else {
                    Some(Rational(res.l / gcd, res.r / gcd));
                }
            }
        }
        None() : None();
    }
}

calculateWrapper(expr: Expression, VarsTree: Tree<string, Rational>) -> Pair<string, Maybe<Rational>> {
    //result = simplify(convertExpressionToPolynom(expr));
    result = simplify((expr));
    
    calcRes = switch(result) {
        BinOp(OpName, l, r) : {
            if (OpName == "/") {
                calcL = calculate(l, VarsTree);
                calcR = calculate(r, VarsTree);
                if (!isNone(calcL) && !isNone(calcR)) {
                    BinOp("/", either(calcL,Error), either(calcR, Error));
                }
                else if (!isNone(calcL)) {
                    BinOp("/", either(calcL,Error), r);
                }
                else if (!isNone(calcR)) {
                    BinOp("/", l, either(calcR, Error));
                }
                else {
                    result;
                }
            } else {
                result;
            }
        }
        default : result;
    }

    switch(normalization(calculate(calcRes, VarsTree))) {
        Some(res) : Pair(InfixToString(calcRes), Some(res));
        None() : Pair(InfixToString(calcRes), None());
    }
}

derivation(expr : Expression, x : Var) -> Expression {
    switch(expr) {
        BinOp(name, l, r) : {
            if (name == "+") {
                BinOp("+", derivation(l,x), derivation(r,x));
            }
            else if (name == "-") {
                BinOp("-", derivation(l,x), derivation(r,x));
            }
            else if (name == "*") {
                BinOp("+", BinOp("*", derivation(l,x), r), BinOp("*", derivation(r,x), l));
            }
            else if (name == "/") {
                switch(l) {
                    Rational(left, right) : {
                        if (r == x) {
                            BinOp("*", l, Var("ln " + x.var));
                        } 
                        else {
                            BinOp("/", BinOp("-", BinOp("*", derivation(l,x), r), BinOp("*", derivation(r,x), l)), BinOp("*", r, r));
                        }
                    }
                    default : BinOp("/", BinOp("-", BinOp("*", derivation(l,x), r), BinOp("*", derivation(r,x), l)), BinOp("*", r, r));
                }
            } else {
                RationalZero;
            }
        }   
        default : {
            if (expr == x) {
				RationalOne;
			} else {
				RationalZero;
			}
        }
    }
}


convertExpressionToPolynom(expr : Expression) -> Expression {
    switch(expr) {
        BinOp(OpName, left, right) : {
            if (OpName == "/") {
                convertPolynomToExpression(calculatePolynom(Polynom(left, right)));
            }
            else {
                convertPolynomToExpression(calculatePolynom(Polynom(expr, RationalOne)));
            }
        }
        default : convertPolynomToExpression(calculatePolynom(Polynom(expr, RationalOne)));
    }
}

convertPolynomToExpression(polynom : Polynom) -> Expression {
    num = polynom.num;
    denom = polynom.denom;
    switch (denom) {
        Rational(left, right) : {
            if (left == 1 && right == 1) {
                num;
            }
            else {
                BinOp("/", num, denom);
            }
        }
        default : BinOp("/", num, denom);
    }
}

calculatePolynom(polynom : Polynom) -> Polynom {

    addPolynoms = \l,r -> {
        Polynom(BinOp("+", BinOp("*", l.num, r.denom), BinOp("*", r.num, l.denom)), BinOp("*", l.denom, r.denom));
    }

    subPolynoms = \l,r -> {
        Polynom(BinOp("-", BinOp("*", l.num, r.denom), BinOp("*", r.num, l.denom)), BinOp("*", l.denom, r.denom));
    }

    multPolynoms = \l,r -> {
        Polynom(BinOp("*", l.num, r.num), BinOp("*", l.denom, r.denom));
    }

    divPolynoms = \l,r -> {
        Polynom(BinOp("*", l.num, r.denom), BinOp("*", l.denom, r.num));
    }

    num = polynom.num;
    denom = polynom.denom;

    resultNum = switch(num) {

        Rational(left, right) : Polynom(Rational(left, 1), Rational(right, 1));
        Var(v) : Polynom(Var(v), RationalOne);

        BinOp(OpName, left, right) : {
            leftPolynom = calculatePolynom(Polynom(left, RationalOne));
            rightPolynom = calculatePolynom(Polynom(right, RationalOne));
            if (OpName == "+") {
                addPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "-") {
                subPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "*") {
                multPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "/") {
                divPolynoms(leftPolynom, rightPolynom);
            }
            else {
                PolynomError;
            }

        }

        Neg(e) : Polynom(Neg(convertPolynomToExpression(calculatePolynom(Polynom(e,RationalOne)))), RationalOne);
        Diff(e,x) : Polynom(Diff(convertPolynomToExpression(calculatePolynom(Polynom(e, RationalOne))),x), RationalOne);

    }

    resultDenom = switch(denom) {

        Rational(left, right) : Polynom(Rational(left, 1), Rational(right, 1));
        Var(v) : Polynom(Var(v), RationalOne);

        BinOp(OpName, left, right) : {
            leftPolynom = calculatePolynom(Polynom(left, RationalOne));
            rightPolynom = calculatePolynom(Polynom(right, RationalOne));
            
            if (OpName == "+") {
                addPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "-") {
                subPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "*") {
                multPolynoms(leftPolynom, rightPolynom);
            }
            else if (OpName == "/") {
                divPolynoms(leftPolynom, rightPolynom);
            }
            else {
                PolynomError;
            }

        }

        Neg(e) : Polynom(Neg(convertPolynomToExpression(calculatePolynom(Polynom(e,RationalOne)))), RationalOne);
        Diff(e,x) : Polynom(Diff(convertPolynomToExpression(calculatePolynom(Polynom(e, RationalOne))),x), RationalOne);

    }

    divPolynoms(resultNum, resultDenom);
}


simplify(exp: Expression) -> Expression {

    splitChildren = \e -> {
        switch(e) {
            Rational(l,r): {
                children = [];
                Pair(Rational(l,r), children);
            }
            Var(v): {
                child = [];
                Pair(Var(v), child);
            }
            BinOp(OpName, l, r) : {
                children = [l, r];
                Pair(Var(OpName), children);
            }
            Neg(n): {
                children = [n];
                Pair(Var("Neg"), children);
            }
            Diff(n,x): {
                children = [n, x];
                Pair(Var("Diff"), children);
            }
        }
    }

    // https://github.com/area9innovation/flow9/blob/master/lib/ds/egraph_matching.flow

    // Given some expression type, and a way to split the children
	// out of a (recursive) expression, build an egraph.
	// The split function should convert `op([1,2])` to the (child-less) parent &
	// the children as in `Pair(op([]), [1,2])`.
	// The clearing of the parent children is required for canonicality.
	// makeEGraph(splitChildren : (?) -> Pair<?, [?]>) -> EGraph<?>;

    myEGraph : EGraph<Expression> = makeEGraph(splitChildren);    
    rootClass = addEExp(myEGraph, exp);

    // Prepare a matching engine to be used with a given EGraph
	//  makeEMatchEngine(e : EGraph<?>, def : ?, 
	//	  // How to construct a value, from a head and recursive arguments
	//	  combine : (head : ?, args : [?]) -> ?,
	//  ) -> EMatchEngine<?>;

    mycombine = \head, args -> {
        switch(head) {
            Rational(l,r) : Rational(l,r);
            Var(v) : {
                if (v == "+") {
                    BinOp("+", args[0], args[1]);
                }
                else if (v == "-") {
                    BinOp("-", args[0], args[1]);
                }
                else if (v == "*") {
                    BinOp("*", args[0], args[1]);
                }
                else if (v == "/") {
                    BinOp("/", args[0], args[1]);
                }
                else if (v == "Neg") {
                    Neg(args[0]);
                }/* idl but it does not working with diff
                else if (v == "Diff") {
                    Diff(args[0], args[1]);
                }*/
                else {
                    Var(v);
                }
            }
            default : head;
        }
    }

    myEMatchEngine : EMatchEngine<Expression> = makeEMatchEngine(myEGraph, exp, mycombine);

    // Performs all replacements possible, repeatedly up to the given number of iterations
	// performEReplacements(e : EMatchEngine<?>, iterations : int, class : int, 
	//  replacements : [EReplacement<?>]) -> void;

	//	EReplacement(
	//		// The pattern to look for
	//		pattern : EPattern<?>, 
	//		// Once we have a match, then construct a new value, and that
	//		// value will be unified with the original
	//		rewrite : (bindings : Tree<string, ?>) -> ?
	//	);

    // Find all matches to this pattern to a given class. Calls the onMatch function
	// for each. Traverses all down recursive
	// findAllEClassMatches(
	// 	    acc : EMatchEngine<?>, class : int, pattern : EPattern<?>, visited : Set<int>,
	//	    onMatch : (bindings : Tree<string, ?>, ?) -> void
	// ) -> Set<int>;


   // firstPattern : EPattern<Expression> = EPatternTerm(Var("+"), [EPatternVar])

    //println(set2String(findAllEClassMatches(myEMatchEngine, 0, firstPattern, makeSet(), \e -> println())));

    //replacements : [EReplacement] = [firstR];
        //EReplacement(EPattern("((x - z) + (y + z))"), parse("(x + y)")),
        //EReplacement(EPattern("((x + z) + (y - z))"), parse("(x + y)")),
        //EReplacement(EPattern("(x + x)"), parse("(2 * x)")),
        //EReplacement(EPattern("(-(-x))"), parse("x")),
        //EReplacement(EPattern("(x + y)"), parse("(y + x)")),
        //EReplacement(EPattern("(x * y)"), parse("(y * x)")),
        //EReplacement(EPattern("(x + 0)"), parse("x")),
        //EReplacement(EPatternTerm()),    // x - 0 -> x
        //EReplacement(EPattern("(x - x)"), parse("0")),
        //EReplacement(EPattern("(x + -x)"), parse("0")),
        //EReplacement(EPattern("(-x + x)"), parse("0")),
        //EReplacement(EPattern("(x * 0)"), parse("0")),
      //  EReplacement(EPattern("(x * 1)"), parse("x")),
     ////   EReplacement(EPattern("(0 + x)"), parse("x"))0
     //   EReplacement(EPattern("(0 - x)"), parse("-x")),
     //   EReplacement(EPattern("(0 * x)"), parse("0")),
      ////  EReplacement(EPattern("(1 * x)"), parse("x")),
      //  EReplacement(EPattern("(x * -1)"), parse("-x")),
     //   EReplacement(EPattern("(-1 * x)"), parse("-x")),
     //   EReplacement(EPattern("(x / x)"), parse("1")),
     //   EReplacement(EPattern("(x * y)"), parse("y*x")),
    //    EReplacement(EPattern("(0 / x)"), parse("0")),
  //      EReplacement(EPattern("((x * z) + (y * z))"), parse("((x + y) * z)")),
    //    EReplacement(EPattern("((x + y) * z)"), parse("((x * z) + (y * z))")),
 //       EReplacement(EPattern("((x + y) + z)"), parse("(x + (y + z))")),
//        EReplacement(EPattern("((x + y) - y)"), parse("x")),
 //       EReplacement(EPattern("((x * y) * z)"), parse("(x * (y * z))")),
 //       EReplacement(EPattern("((x * x) - (y * y))"), parse("((x - y) * (x + y))")),
 //       EReplacement(EPattern("((x - y) * (x + y))"), parse("((x * x) - (y * y))")),
  //      EReplacement(EPattern("((x - y) * (x - y))"), parse("(((x * x) + (y * y)) - (2 * (x * y)))")),
 //       EReplacement(EPattern("(((x * x) + (y * y)) - (2 * (x * y)))"), parse("((x - y) * (x - y))")),
 //       EReplacement(EPattern("((x + y) * (x + y))"), parse("(((x * x) + (y * y)) + (2 * (x * y)))")),
//        EReplacement(EPattern("(((x * x) + (y * y)) + (2 * (x * y)))"), parse("((x + y) * (x + y))")),
//    ];

    //performEReplacements(myEMatchEngine, 1, rootClass, []);
    convertEGraphToExpression(myEGraph, rootClass,exp);
}

convertEGraphToExpression(graph : EGraph<Expression>, rootClass : int, exp : Expression) -> Expression {

    isOp = \e -> {
        switch(e) {
            Var(v) : {
                if (v == "+") {
                    true;
                }
                else if (v == "-") {
                    true;
                }
                else if (v == "*") {
                    true;
                }
                else if (v == "/") {
                    true;
                }
                else if (v == "Neg") {
                    true;
                }
                else {
                    false;
                }
            }
            default : false;
        }
    }


    println("RootClass = " + i2s(rootClass));

    // println(InfixToString(getCurrNode(graph, rootClass).head));

    currNode = getCurrNode(graph, rootClass);
    if (isOp(currNode.head)) {
        switch(currNode.head) {
            Var(v) : {
                if (v == "Neg") {
                    n = ;
                    Neg(n);
                }
                else {
                    left = ;
                    right = ;
                    if (v == "+") {
                        BinOp("+", left, right);
                    }
                    else if (v == "-") {
                        BinOp("-", left, right);
                    }
                    else if (v == "*") {
                        BinOp("*", left, right);
                    }
                    else if (v == "/") {
                        BinOp("/", left, right);
                    }
                    else {
                        false;
                    }
                }
            }
            default: Error;
    }

    exp;
}

getCurrNode(graph : EGraph<Expression>, currClass : int) -> ENode<Expression> {
    currNode = set2array(getEClassNodes(graph, currClass));
    currNode[0];
}