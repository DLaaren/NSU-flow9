import lingo/pegcode/driver;
import string;
import math/math;
import maybe;

import infix;

export {
    RPNExpression ::= Const, OpName;
    OpName(name : string);

    RPNExprToString(RPNexpr: [RPNExpression]) -> string;
    RPNcalculate(RPNexpr: [RPNExpression]) -> Maybe<double>;
}

RPNExprToString(RPNexpr: [RPNExpression]) -> string {
    fold(RPNexpr, "", \str, val -> {
        switch(val) {
            Const(c) : str + d2s(c) + " ";
            OpName(name) : str + name + " ";
        }
    });


}

RPNcalculate(RPNexpr: [RPNExpression]) -> Maybe<double> {
    // map : ([?], (?) -> ??) -> [??];
    // fold : (xs : [?], init : ??, fn : (??, ?)->??) -> ??
    // arrayPush : ([?], ?) -> [?];
    // removeIndex(a : [?], index : int) -> [?];
    // lastElement(a: [?], def: ?) -> ?;
    // lastElement(map(stack, \elem -> Some(elem)), None());

    stack : [Maybe<double>] = [];

    result = fold(RPNexpr, stack, \st, e -> {
        switch(e) {
            Const(c) : arrayPush(st, Some(c));
            OpName(name) : {
                left = lastElement(st, None());
                a = removeIndex(st, length(st) - 1);

                right = lastElement(a, None());
                b = removeIndex(a, length(a) - 1);

                switch(left) {
                    Some(l) : switch(right) {
                        Some(r) : {
                            if (name == "+") {
                                arrayPush(b, Some(l + r));
                            }
                            else if (name == "*") {
                                arrayPush(b, Some(l * r));
                            } else {
                                arrayPush(b, None());
                            }
                        };
                        None() : arrayPush(b, None());
                    }
                    None() : arrayPush(b, None());
                }
            }
        }
    });
    result[0];    
}

/*
translateToInfix(RPNExpr : RPNExpression) -> Expression {

}

translateToPostfix(Expr : Expression) -> RPNExpression {
    
}
*/







/* old version
import lingo/pegcode/driver;
import string;
import math/math;
import maybe;

import infix;

export {
    RPNExpression ::= Const, OpName;
    OpName(name : string);

    RPNExprToString(RPNexpr: [RPNExpression]) -> string;
    RPNcalculate(RPNexpr: [RPNExpression]) -> Maybe<double>;
}

RPNExprToString(RPNexpr: [RPNExpression]) -> string {
    fold(RPNexpr, "", \str, val -> {
        switch(val) {
            Const(c) : str + d2s(c) + " ";
            OpName(name) : str + name + " ";
        }
    });


}

RPNcalculate(RPNexpr: [RPNExpression]) -> Maybe<double> {
    stack : [double] = [];

    // map : ([?], (?) -> ??) -> [??];
    // fold : (xs : [?], init : ??, fn : (??, ?)->??) -> ??
    // arrayPush : ([?], ?) -> [?];
    // removeIndex(a : [?], index : int) -> [?];
    // lastElement(a: [?], def: ?) -> ?;
    // lastElement(map(stack, \elem -> Some(elem)), None());

    result = fold(RPNexpr, stack, \st, e -> {
        switch(e) {
            Const(c) : arrayPush(stack, c);
            OpName(name) : {
                left = lastElement(map(stack, \elem -> Some(elem)), None());
                a = removeIndex(stack, length(stack) - 1);

                right = lastElement(map(a, \elem -> Some(elem)), None());
                b = removeIndex(a, length(a) - 1);

                switch(left) {
                    Some(l) : switch(right) {
                        Some(r) : {
                            if (name == "+") {
                                arrayPush(b, l + r);
                            }
                            else if (name == "*") {
                                arrayPush(b, l * r);
                            } else {
                                arrayPush(b, None());
                            }
                        };
                        None() : arrayPush(b, None());
                    }
                    None() : arrayPush(b, None());
                }
            }
        }
    });
    result[0];    
}

/*
translateToInfix(RPNExpr : RPNExpression) -> Expression {

}

translateToPostfix(Expr : Expression) -> RPNExpression {
    
}
*/
*/